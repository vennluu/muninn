// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: gdp_stats.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getGDPStats = `-- name: GetGDPStats :many
SELECT 
    DATE_TRUNC($1::text, o.created_at)::TEXT AS date,
    COALESCE(SUM(
        CASE 
            WHEN (otv.type_values ->> ot.gdp_measure_field) ~ '^-?[0-9]+(\.[0-9]+)?$' 
            THEN (otv.type_values ->> ot.gdp_measure_field)::NUMERIC 
            ELSE 0 
        END
    ), 0)::FLOAT AS count
FROM obj o
JOIN obj_type_value otv ON o.id = otv.obj_id
JOIN obj_type ot ON otv.type_id = ot.id
JOIN creator c ON o.creator_id = c.id
WHERE 
    ot.gdp_measure_field IS NOT NULL 
    AND ot.gdp_measure_field != ''
    AND o.deleted_at IS NULL
    AND c.org_id = $2
GROUP BY 1
ORDER BY 1 DESC
`

type GetGDPStatsParams struct {
	Interval string    `json:"interval"`
	OrgID    uuid.UUID `json:"org_id"`
}

type GetGDPStatsRow struct {
	Date  string  `json:"date"`
	Count float64 `json:"count"`
}

func (q *Queries) GetGDPStats(ctx context.Context, arg GetGDPStatsParams) ([]GetGDPStatsRow, error) {
	rows, err := q.query(ctx, q.getGDPStatsStmt, getGDPStats, arg.Interval, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGDPStatsRow
	for rows.Next() {
		var i GetGDPStatsRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
