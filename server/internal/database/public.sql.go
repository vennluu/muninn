// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: public.sql

package database

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const getObjectsByTypeStats = `-- name: GetObjectsByTypeStats :many
SELECT ot.id, ot.name, COUNT(DISTINCT otv.obj_id) as object_count
FROM obj_type ot
JOIN creator c ON ot.creator_id = c.id
LEFT JOIN obj_type_value otv ON ot.id = otv.type_id
WHERE c.org_id = $1 AND ot.deleted_at IS NULL AND ot.is_public = true
GROUP BY ot.id, ot.name
`

type GetObjectsByTypeStatsRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	ObjectCount int64     `json:"object_count"`
}

func (q *Queries) GetObjectsByTypeStats(ctx context.Context, orgID uuid.UUID) ([]GetObjectsByTypeStatsRow, error) {
	rows, err := q.query(ctx, q.getObjectsByTypeStatsStmt, getObjectsByTypeStats, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsByTypeStatsRow
	for rows.Next() {
		var i GetObjectsByTypeStatsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.ObjectCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicObject = `-- name: GetPublicObject :one
SELECT o.id, o.name, o.description, o.photo, c.username as creator_name, o.created_at
FROM obj o
JOIN creator c ON o.creator_id = c.id
WHERE o.id = $1 AND c.org_id = $2 AND o.deleted_at IS NULL
`

type GetPublicObjectParams struct {
	ID    uuid.UUID `json:"id"`
	OrgID uuid.UUID `json:"org_id"`
}

type GetPublicObjectRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Photo       string    `json:"photo"`
	CreatorName string    `json:"creator_name"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) GetPublicObject(ctx context.Context, arg GetPublicObjectParams) (GetPublicObjectRow, error) {
	row := q.queryRow(ctx, q.getPublicObjectStmt, getPublicObject, arg.ID, arg.OrgID)
	var i GetPublicObjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Photo,
		&i.CreatorName,
		&i.CreatedAt,
	)
	return i, err
}

const getPublicObjectFacts = `-- name: GetPublicObjectFacts :many
SELECT f.id, f.text, f.happened_at, c.username as creator_name, c.profile as creator_profile
FROM fact f
JOIN creator c ON f.creator_id = c.id
JOIN obj_fact of_link ON f.id = of_link.fact_id
WHERE of_link.obj_id = $1 
  AND c.org_id = $2
  AND f.deleted_at IS NULL
ORDER BY f.happened_at DESC
`

type GetPublicObjectFactsParams struct {
	ObjID uuid.UUID `json:"obj_id"`
	OrgID uuid.UUID `json:"org_id"`
}

type GetPublicObjectFactsRow struct {
	ID             uuid.UUID       `json:"id"`
	Text           string          `json:"text"`
	HappenedAt     sql.NullTime    `json:"happened_at"`
	CreatorName    string          `json:"creator_name"`
	CreatorProfile json.RawMessage `json:"creator_profile"`
}

func (q *Queries) GetPublicObjectFacts(ctx context.Context, arg GetPublicObjectFactsParams) ([]GetPublicObjectFactsRow, error) {
	rows, err := q.query(ctx, q.getPublicObjectFactsStmt, getPublicObjectFacts, arg.ObjID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicObjectFactsRow
	for rows.Next() {
		var i GetPublicObjectFactsRow
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.HappenedAt,
			&i.CreatorName,
			&i.CreatorProfile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicObjectTypeValues = `-- name: GetPublicObjectTypeValues :many
SELECT ot.name as type_name, otv.type_values, ot.id as type_id, ot.description, ot.icon, ot.fields
FROM obj_type_value otv
JOIN obj_type ot ON otv.type_id = ot.id
WHERE otv.obj_id = $1 AND ot.deleted_at IS NULL
`

type GetPublicObjectTypeValuesRow struct {
	TypeName    string          `json:"type_name"`
	TypeValues  json.RawMessage `json:"type_values"`
	TypeID      uuid.UUID       `json:"type_id"`
	Description string          `json:"description"`
	Icon        string          `json:"icon"`
	Fields      json.RawMessage `json:"fields"`
}

func (q *Queries) GetPublicObjectTypeValues(ctx context.Context, objID uuid.UUID) ([]GetPublicObjectTypeValuesRow, error) {
	rows, err := q.query(ctx, q.getPublicObjectTypeValuesStmt, getPublicObjectTypeValues, objID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicObjectTypeValuesRow
	for rows.Next() {
		var i GetPublicObjectTypeValuesRow
		if err := rows.Scan(
			&i.TypeName,
			&i.TypeValues,
			&i.TypeID,
			&i.Description,
			&i.Icon,
			&i.Fields,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicObjectTypes = `-- name: GetPublicObjectTypes :many
SELECT ot.id, ot.name, ot.description, ot.icon, COUNT(DISTINCT otv.obj_id) as object_count
FROM obj_type ot
JOIN creator c ON ot.creator_id = c.id
LEFT JOIN obj_type_value otv ON ot.id = otv.type_id
WHERE c.org_id = $1 AND ot.deleted_at IS NULL AND ot.is_public = true
GROUP BY ot.id, ot.name, ot.description, ot.icon
ORDER BY object_count DESC
`

type GetPublicObjectTypesRow struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Icon        string    `json:"icon"`
	ObjectCount int64     `json:"object_count"`
}

func (q *Queries) GetPublicObjectTypes(ctx context.Context, orgID uuid.UUID) ([]GetPublicObjectTypesRow, error) {
	rows, err := q.query(ctx, q.getPublicObjectTypesStmt, getPublicObjectTypes, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicObjectTypesRow
	for rows.Next() {
		var i GetPublicObjectTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.ObjectCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicObjectsByType = `-- name: GetPublicObjectsByType :many
SELECT o.id, o.name, o.description, o.photo, ot.name as type_name, otv.type_values, COUNT(of_link.fact_id) as fact_count
FROM obj o
JOIN creator c ON o.creator_id = c.id
JOIN obj_type_value otv ON o.id = otv.obj_id
LEFT JOIN obj_type ot ON otv.type_id = ot.id
LEFT JOIN obj_fact of_link ON o.id = of_link.obj_id
WHERE c.org_id = $1 
  AND o.deleted_at IS NULL
  AND otv.type_id = $2
GROUP BY o.id, o.name, o.description, o.photo, ot.name, otv.type_values
ORDER BY fact_count DESC
LIMIT 50
`

type GetPublicObjectsByTypeParams struct {
	OrgID  uuid.UUID `json:"org_id"`
	TypeID uuid.UUID `json:"type_id"`
}

type GetPublicObjectsByTypeRow struct {
	ID          uuid.UUID       `json:"id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Photo       string          `json:"photo"`
	TypeName    sql.NullString  `json:"type_name"`
	TypeValues  json.RawMessage `json:"type_values"`
	FactCount   int64           `json:"fact_count"`
}

func (q *Queries) GetPublicObjectsByType(ctx context.Context, arg GetPublicObjectsByTypeParams) ([]GetPublicObjectsByTypeRow, error) {
	rows, err := q.query(ctx, q.getPublicObjectsByTypeStmt, getPublicObjectsByType, arg.OrgID, arg.TypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicObjectsByTypeRow
	for rows.Next() {
		var i GetPublicObjectsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Photo,
			&i.TypeName,
			&i.TypeValues,
			&i.FactCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicRecentFacts = `-- name: GetPublicRecentFacts :many
SELECT f.id, f.text, f.happened_at, c.username as creator_name, c.profile as creator_profile
FROM fact f
JOIN creator c ON f.creator_id = c.id
WHERE c.org_id = $1 AND f.deleted_at IS NULL
ORDER BY f.happened_at DESC
LIMIT 20
`

type GetPublicRecentFactsRow struct {
	ID             uuid.UUID       `json:"id"`
	Text           string          `json:"text"`
	HappenedAt     sql.NullTime    `json:"happened_at"`
	CreatorName    string          `json:"creator_name"`
	CreatorProfile json.RawMessage `json:"creator_profile"`
}

func (q *Queries) GetPublicRecentFacts(ctx context.Context, orgID uuid.UUID) ([]GetPublicRecentFactsRow, error) {
	rows, err := q.query(ctx, q.getPublicRecentFactsStmt, getPublicRecentFacts, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicRecentFactsRow
	for rows.Next() {
		var i GetPublicRecentFactsRow
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.HappenedAt,
			&i.CreatorName,
			&i.CreatorProfile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicRecentFactsByType = `-- name: GetPublicRecentFactsByType :many
SELECT DISTINCT f.id, f.text, f.happened_at, c.username as creator_name, c.profile as creator_profile
FROM fact f
JOIN creator c ON f.creator_id = c.id
JOIN obj_fact of_link ON f.id = of_link.fact_id
JOIN obj o ON of_link.obj_id = o.id
JOIN obj_type_value otv ON o.id = otv.obj_id
WHERE c.org_id = $1 
  AND f.deleted_at IS NULL
  AND otv.type_id = $2
ORDER BY f.happened_at DESC
LIMIT 20
`

type GetPublicRecentFactsByTypeParams struct {
	OrgID  uuid.UUID `json:"org_id"`
	TypeID uuid.UUID `json:"type_id"`
}

type GetPublicRecentFactsByTypeRow struct {
	ID             uuid.UUID       `json:"id"`
	Text           string          `json:"text"`
	HappenedAt     sql.NullTime    `json:"happened_at"`
	CreatorName    string          `json:"creator_name"`
	CreatorProfile json.RawMessage `json:"creator_profile"`
}

func (q *Queries) GetPublicRecentFactsByType(ctx context.Context, arg GetPublicRecentFactsByTypeParams) ([]GetPublicRecentFactsByTypeRow, error) {
	rows, err := q.query(ctx, q.getPublicRecentFactsByTypeStmt, getPublicRecentFactsByType, arg.OrgID, arg.TypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicRecentFactsByTypeRow
	for rows.Next() {
		var i GetPublicRecentFactsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.HappenedAt,
			&i.CreatorName,
			&i.CreatorProfile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicStats = `-- name: GetPublicStats :one
SELECT 
    (SELECT COUNT(*) FROM obj o JOIN creator c ON o.creator_id = c.id WHERE c.org_id = $1 AND o.deleted_at IS NULL) as object_count,
    (SELECT COUNT(*) FROM fact f JOIN creator c ON f.creator_id = c.id WHERE c.org_id = $1 AND f.deleted_at IS NULL) as fact_count,
    (SELECT COUNT(*) FROM creator c WHERE c.org_id = $1 AND c.active = true) as creator_count
`

type GetPublicStatsRow struct {
	ObjectCount  int64 `json:"object_count"`
	FactCount    int64 `json:"fact_count"`
	CreatorCount int64 `json:"creator_count"`
}

func (q *Queries) GetPublicStats(ctx context.Context, orgID uuid.UUID) (GetPublicStatsRow, error) {
	row := q.queryRow(ctx, q.getPublicStatsStmt, getPublicStats, orgID)
	var i GetPublicStatsRow
	err := row.Scan(&i.ObjectCount, &i.FactCount, &i.CreatorCount)
	return i, err
}

const getPublicTopObjects = `-- name: GetPublicTopObjects :many
SELECT o.id, o.name, o.description, o.photo, ot.name as type_name, COUNT(of_link.fact_id) as fact_count
FROM obj o
JOIN creator c ON o.creator_id = c.id
LEFT JOIN obj_type_value otv ON o.id = otv.obj_id
LEFT JOIN obj_type ot ON otv.type_id = ot.id
LEFT JOIN obj_fact of_link ON o.id = of_link.obj_id
WHERE c.org_id = $1 AND o.deleted_at IS NULL
GROUP BY o.id, o.name, o.description, o.photo, ot.name
ORDER BY fact_count DESC
LIMIT 10
`

type GetPublicTopObjectsRow struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Photo       string         `json:"photo"`
	TypeName    sql.NullString `json:"type_name"`
	FactCount   int64          `json:"fact_count"`
}

func (q *Queries) GetPublicTopObjects(ctx context.Context, orgID uuid.UUID) ([]GetPublicTopObjectsRow, error) {
	rows, err := q.query(ctx, q.getPublicTopObjectsStmt, getPublicTopObjects, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicTopObjectsRow
	for rows.Next() {
		var i GetPublicTopObjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Photo,
			&i.TypeName,
			&i.FactCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizations = `-- name: ListOrganizations :many
SELECT id, name, profile FROM org
`

type ListOrganizationsRow struct {
	ID      uuid.UUID       `json:"id"`
	Name    string          `json:"name"`
	Profile json.RawMessage `json:"profile"`
}

func (q *Queries) ListOrganizations(ctx context.Context) ([]ListOrganizationsRow, error) {
	rows, err := q.query(ctx, q.listOrganizationsStmt, listOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationsRow
	for rows.Next() {
		var i ListOrganizationsRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Profile); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
